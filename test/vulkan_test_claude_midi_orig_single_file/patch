@@
-use std::{ffi::CString, ptr, time::{Instant, Duration}, sync::{Arc, Mutex}, path::Path, fs};
+use std::{ffi::CString, ptr, time::{Instant, Duration}, sync::{Arc, Mutex}, path::Path, fs, collections::VecDeque};
@@
 use midir::{MidiInput, Ignore};
+use cpal::{traits::{DeviceTrait, HostTrait, StreamTrait}};
+use rustfft::{FftPlanner, num_complex::Complex32};
@@
 struct Config {
     #[serde(default)]
     window: WindowConfig,
     #[serde(default)]
     midi: MidiConfig,
     #[serde(default)]
     graphics: GraphicsConfig,
+    #[serde(default)]
+    audio: AudioConfig,
 }
@@
 struct GraphicsConfig {
     #[serde(default = "default_true")]
     vsync: bool,
     #[serde(default = "default_true")]
     validation_layers: bool,
 }
+
+#[derive(Deserialize, Serialize)]
+struct AudioConfig {
+    #[serde(default = "default_true")]
+    enabled: bool,
+    #[serde(default)]
+    device_name: Option<String>,
+    #[serde(default)]
+    sample_rate: Option<u32>,
+}
@@
 impl Default for Config {
     fn default() -> Self {
         Self {
             window: WindowConfig::default(),
             midi: MidiConfig::default(),
             graphics: GraphicsConfig::default(),
+            audio: AudioConfig::default(),
         }
     }
 }
@@
 impl Default for GraphicsConfig {
     fn default() -> Self {
         Self {
             vsync: default_true(),
             validation_layers: cfg!(debug_assertions),
         }
     }
 }
+
+impl Default for AudioConfig {
+    fn default() -> Self {
+        Self {
+            enabled: false,
+            device_name: None,
+            sample_rate: None,
+        }
+    }
+}
@@
     fn merge_with_args(&mut self, args: &Args) {
         if args.fullscreen {
             self.window.fullscreen = true;
         }
@@
         if let Some(ref title) = args.title {
             self.window.title = title.clone();
         }
     }
 }
@@
 struct PushConstants {
     time: f32,
     mouse_x: u32,
     mouse_y: u32,
     mouse_pressed: u32,
     // MIDI data
     note_velocity: f32,       // Velocity of last played note
     pitch_bend: f32,          // Pitch bend value
     cc1: f32,                 // Modulation wheel (CC1)
     cc74: f32,                // Filter cutoff (CC74)
     note_count: u32,          // Number of notes pressed
     last_note: u32,           // Last note number
 }
@@
 struct App {
     window: Option<Window>,
     gfx: Option<Gfx>,
     start_time: Option<Instant>,
     mouse_pos: (f64, f64),
     mouse_pressed: bool,
     midi_state: Arc<Mutex<MidiState>>,
     _midi_connection: Option<midir::MidiInputConnection<()>>,
+    audio_state: Arc<Mutex<AudioState>>,
+    _audio_stream: Option<cpal::Stream>,
     config: Config,
     is_fullscreen: bool,
 }
@@
     fn new(config: Config) -> Self {
         let is_fullscreen = config.window.fullscreen;
         Self {
             window: None,
             gfx: None,
             start_time: None,
             mouse_pos: (0.0, 0.0),
             mouse_pressed: false,
             midi_state: Arc::new(Mutex::new(MidiState::default())),
             _midi_connection: None,
+            audio_state: Arc::new(Mutex::new(AudioState::new())),
+            _audio_stream: None,
             config,
             is_fullscreen,
         }
     }
@@
     fn setup_midi(&mut self) {
         if !self.config.midi.enabled {
             println!("MIDI disabled in configuration");
             return;
         }
@@
         }
     }
 
+    fn setup_audio(&mut self) {
+        if !self.config.audio.enabled {
+            println!("Audio input disabled in configuration");
+            return;
+        }
+
+        let host = cpal::default_host();
+        let mut device = match &self.config.audio.device_name {
+            Some(substr) => {
+                let dev = host.input_devices().ok()
+                    .and_then(|mut it| it.find(|d| d.name().map(|n| n.contains(substr)).unwrap_or(false)));
+                dev.or_else(|| host.default_input_device())
+            }
+            None => host.default_input_device(),
+        };
+
+        let device = match device.take() {
+            Some(d) => d,
+            None => { eprintln!("No input audio device found"); return; }
+        };
+
+        let mut supported = match device.supported_input_configs() {
+            Ok(cfgs) => cfgs.collect::<Vec<_>>(),
+            Err(e) => { eprintln!("Failed to query audio formats: {}", e); return; }
+        };
+        if supported.is_empty() {
+            eprintln!("No supported audio input configs");
+            return;
+        }
+
+        // Choose a format: f32, desired sample rate if possible
+        let desired_sr = self.config.audio.sample_rate;
+        let mut chosen = None;
+        for cfg in &supported {
+            let sr = desired_sr.unwrap_or(cfg.max_sample_rate().0);
+            if cfg.sample_format() == cpal::SampleFormat::F32 &&
+               cfg.min_sample_rate().0 <= sr && sr <= cfg.max_sample_rate().0 {
+                chosen = Some(cfg.with_max_sample_rate().config());
+                if let Some(req) = desired_sr {
+                    let mut c = cfg.clone().with_sample_rate(cpal::SampleRate(req));
+                    chosen = Some(c.config());
+                    break;
+                }
+                break;
+            }
+        }
+        let config = chosen.unwrap_or_else(|| supported[0].with_max_sample_rate().config());
+
+        println!("Using audio device: {}", device.name().unwrap_or_else(|_| "Unknown".into()));
+        println!("Audio config: {:?}Hz, {:?}ch", config.sample_rate.0, config.channels);
+
+        // Build input stream
+        let audio_state = Arc::clone(&self.audio_state);
+        let channels = config.channels as usize;
+        let stream = match device.build_input_stream(
+            &config,
+            move |data: &[f32], _| {
+                // Mixdown to mono and push into buffer
+                let mut mono: Vec<f32> = Vec::with_capacity(data.len()/channels + 1);
+                for frame in data.chunks_exact(channels) {
+                    let s = frame.iter().copied().sum::<f32>() / (channels as f32);
+                    mono.push(s);
+                }
+                if let Ok(mut st) = audio_state.lock() {
+                    st.push_samples(&mono, config.sample_rate.0);
+                }
+            },
+            move |err| {
+                eprintln!("Audio input error: {}", err);
+            },
+            None
+        ) {
+            Ok(s) => s,
+            Err(e) => { eprintln!("Failed to build audio input stream: {}", e); return; }
+        };
+
+        if let Err(e) = stream.play() {
+            eprintln!("Failed to start audio stream: {}", e);
+            return;
+        }
+        self._audio_stream = Some(stream);
+        println!("Audio input connected successfully!");
+    }
+
     fn try_setup_midi(&mut self) -> Result<midir::MidiInputConnection<()>, Box<dyn std::error::Error>> {
         let mut midi_in = MidiInput::new("Vulkan MIDI Visualizer")?;
         midi_in.ignore(Ignore::None);
@@
     fn handle_midi_message(midi_state: &Arc<Mutex<MidiState>>, message: &[u8]) {
@@
     }
 }
 
+// --------- Audio analysis (very lightweight) ---------
+#[derive(Clone, Debug)]
+struct AudioState {
+    ring: VecDeque<f32>,
+    capacity: usize,
+    last_sample_rate: u32,
+    level_rms: f32,
+    low: f32,
+    mid: f32,
+    high: f32,
+}
+
+impl AudioState {
+    fn new() -> Self {
+        Self {
+            ring: VecDeque::with_capacity(4096),
+            capacity: 4096,
+            last_sample_rate: 48000,
+            level_rms: 0.0,
+            low: 0.0, mid: 0.0, high: 0.0,
+        }
+    }
+
+    fn push_samples(&mut self, samples: &[f32], sr: u32) {
+        self.last_sample_rate = sr;
+        for &s in samples {
+            if self.ring.len() == self.capacity { self.ring.pop_front(); }
+            self.ring.push_back(s);
+        }
+    }
+
+    /// Compute snapshot features (RMS + 3 bands via FFT) from current buffer.
+    fn snapshot(&mut self) {
+        // Take up to 1024 latest samples
+        let n: usize = 1024;
+        if self.ring.is_empty() {
+            self.level_rms = 0.0; self.low = 0.0; self.mid = 0.0; self.high = 0.0;
+            return;
+        }
+        let take = n.min(self.ring.len());
+        let mut buf: Vec<f32> = self.ring.iter().rev().take(take).cloned().collect();
+        buf.reverse();
+
+        // RMS
+        let rms = (buf.iter().map(|x| x * x).sum::<f32>() / (buf.len() as f32)).sqrt();
+
+        // Hann window + FFT
+        let fft_len = buf.len().next_power_of_two().max(256).min(2048);
+        buf.resize(fft_len, 0.0);
+        for (i, x) in buf.iter_mut().enumerate() {
+            let w = 0.5 * (1.0 - (2.0 * std::f32::consts::PI * i as f32 / (fft_len as f32)).cos());
+            *x *= w as f32;
+        }
+        let mut planner = FftPlanner::<f32>::new();
+        let fft = planner.plan_fft_forward(fft_len);
+        let mut spectrum: Vec<Complex32> = buf.into_iter().map(|v| Complex32::new(v, 0.0)).collect();
+        fft.process(&mut spectrum);
+
+        // Sum magnitudes into 3 coarse bands
+        let sr = self.last_sample_rate as f32;
+        let bin_hz = sr / (fft_len as f32);
+        let mut low = 0.0;   // ~20–250 Hz
+        let mut mid = 0.0;   // ~250–2k Hz
+        let mut high = 0.0;  // ~2k–8k Hz
+        for (i, c) in spectrum.iter().enumerate().take(fft_len/2) {
+            let f = i as f32 * bin_hz;
+            let mag = c.norm();
+            if f < 20.0 { continue; }
+            if f <= 250.0 { low += mag; }
+            else if f <= 2000.0 { mid += mag; }
+            else if f <= 8000.0 { high += mag; }
+        }
+        // Normalize crudely and smooth a bit
+        let norm = |x: f32| (x / 1000.0).min(1.0);
+        let a = 0.7; // smoothing
+        self.level_rms = a * self.level_rms + (1.0 - a) * rms.min(1.0);
+        self.low = a * self.low + (1.0 - a) * norm(low);
+        self.mid = a * self.mid + (1.0 - a) * norm(mid);
+        self.high = a * self.high + (1.0 - a) * norm(high);
+    }
+}
+
 impl ApplicationHandler for App {
     fn resumed(&mut self, event_loop: &ActiveEventLoop) {
@@
-        // Setup MIDI based on config
+        // Setup MIDI based on config
         self.setup_midi();
+        // Setup Audio input if enabled
+        self.setup_audio();
@@
             WindowEvent::RedrawRequested => {
                 if let (Some(gfx), Some(start_time)) = (&self.gfx, &self.start_time) {
                     let elapsed = start_time.elapsed().as_secs_f32();
 
                     let midi_state = match self.midi_state.lock() {
                         Ok(state) => state,
                         Err(_) => return,
                     };
+                    // Update audio snapshot
+                    let (mut level, mut band_low, mut band_mid, mut band_high) = (0.0f32, 0.0, 0.0, 0.0);
+                    if let Ok(mut a) = self.audio_state.lock() {
+                        a.snapshot();
+                        level = a.level_rms;
+                        band_low = a.low;
+                        band_mid = a.mid;
+                        band_high = a.high;
+                    }
 
                     let note_velocity = if midi_state.note_count > 0 {
                         midi_state.notes[midi_state.last_note as usize]
                     } else {
                         0.0
                     };
 
-                    let push_constants = PushConstants {
+                    // Blend MIDI with audio by taking the max (so either source can drive visuals)
+                    let blended_velocity = note_velocity.max(level);
+                    let blended_pitch_bend = midi_state.pitch_bend.max(band_low * 2.0 - 1.0); // map [0,1]→[-1,1]
+                    let blended_cc1 = midi_state.controllers[1].max(band_mid);
+                    let blended_cc74 = midi_state.controllers[74].max(band_high);
+
+                    let push_constants = PushConstants {
                         time: elapsed,
                         mouse_x: self.mouse_pos.0 as u32,
                         mouse_y: self.mouse_pos.1 as u32,
                         mouse_pressed: if self.mouse_pressed { 1 } else { 0 },
-                        note_velocity,
-                        pitch_bend: midi_state.pitch_bend,
-                        cc1: midi_state.controllers[1],
-                        cc74: midi_state.controllers[74],
+                        note_velocity: blended_velocity,
+                        pitch_bend: blended_pitch_bend,
+                        cc1: blended_cc1,
+                        cc74: blended_cc74,
                         note_count: midi_state.note_count,
                         last_note: midi_state.last_note as u32,
                     };
@@
 fn main() -> Result<()> {
@@
-    println!("MIDI: {}", if config.midi.enabled { "Enabled" } else { "Disabled" });
+    println!("MIDI: {}", if config.midi.enabled { "Enabled" } else { "Disabled" });
+    println!("Audio: {}", if config.audio.enabled { "Enabled" } else { "Disabled" });
@@
-    let mut app = App::new(config);
+    let mut app = App::new(config);
     event_loop.run_app(&mut app);
     Ok(())
 }
